// -------------------------------------
//  Domain		: IBT / Realtime.co
//  Author		: Nicholas Ventimiglia
//  Product		: Messaging and Storage
//  Published	: 2014
//  -------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Realtime.Ortc.Api
{
    /// <summary>
    ///     ORTC server side API that contains ORTC factories as plug-ins.
    /// </summary>
    public class AuthenticationClient
    {
        /// <summary>
        ///     Saves the authentication token channels permissions in the ORTC server.
        /// </summary>
        /// <param name="url">ORTC server URL.</param>
        /// <param name="isCluster">Indicates whether the ORTC server is in a cluster.</param>
        /// <param name="authenticationToken">
        ///     Authentication Token which is generated by the application server, for instance a
        ///     unique session ID.
        /// </param>
        /// <param name="authenticationTokenIsPrivate">Indicates whether the authentication token is private (1) or not (0).</param>
        /// <param name="applicationKey">Application Key that was provided to you together with the ORTC service purchasing.</param>
        /// <param name="timeToLive">The authentication token time to live, in other words, the allowed activity time (in seconds).</param>
        /// <param name="privateKey">The private key provided to you together with the ORTC service purchasing.</param>
        /// <param name="permissions">The channels and their permissions (w: write/read or r: read, case sensitive).</param>
        /// <returns>True if the authentication was successful or false if it was not.</returns>
        public static void PostAuthentication(
            string url,
            bool isCluster,
            string authenticationToken,
            bool authenticationTokenIsPrivate,
            string applicationKey,
            int timeToLive,
            string privateKey,
            Dictionary<string, List<ChannelPermissions>> permissions,
            Action<OrtcException, string> callback
            )
        {
            #region Sanity Checks

            if (string.IsNullOrEmpty(url))
            {
                callback(new OrtcException(OrtcExceptionReason.InvalidArguments, "URL is null or emptyt."), string.Empty);
            }
            if (string.IsNullOrEmpty(applicationKey))
            {
                callback(new OrtcException(OrtcExceptionReason.InvalidArguments, "Application Key is null or empty."),
                    string.Empty);
            }
            if (string.IsNullOrEmpty(authenticationToken))
            {
                callback(
                    new OrtcException(OrtcExceptionReason.InvalidArguments, "Authentication Token is null or empty."),
                    string.Empty);
            }
            if (string.IsNullOrEmpty(privateKey))
            {
                callback(new OrtcException(OrtcExceptionReason.InvalidArguments, "NoPrivate Key is null or empty."),
                    string.Empty);
            }
            if (permissions != null && permissions.Count == 0)
            {
                callback(new OrtcException(OrtcExceptionReason.InvalidArguments, "No permissions set."), string.Empty);
            }

            #endregion

            if (isCluster)
            {
                ClusterClient.GetClusterServerWithRetry(url, applicationKey, (exception, s) =>
                {
                    if (exception)
                    {
                        callback(exception, string.Empty);
                    }
                    else
                    {
                        RealtimeProxy.Instance.StartCoroutine(PostAuthenticationAsync(s, authenticationToken,
                            authenticationTokenIsPrivate, applicationKey, timeToLive, privateKey, permissions, callback));
                    }
                });
            }
            else
            {
                RealtimeProxy.Instance.StartCoroutine(PostAuthenticationAsync(url, authenticationToken,
                    authenticationTokenIsPrivate, applicationKey, timeToLive, privateKey, permissions, callback));
            }
        }


        private static IEnumerator PostAuthenticationAsync(
            string connectionUrl,
            string authenticationToken,
            bool authenticationTokenIsPrivate,
            string applicationKey,
            int timeToLive,
            string privateKey,
            Dictionary<string, List<ChannelPermissions>> permissions,
            Action<OrtcException, string> callback)
        {
            connectionUrl = connectionUrl[connectionUrl.Length - 1] == '/' ? connectionUrl : connectionUrl + "/";

            var postParameters = string.Format("AT={0}&PVT={1}&AK={2}&TTL={3}&PK={4}", authenticationToken,
                authenticationTokenIsPrivate
                    ? 1
                    : 0, applicationKey, timeToLive, privateKey);

            if (permissions != null && permissions.Count > 0)
            {
                postParameters += string.Format("&TP={0}", permissions.Count);
                foreach (var permission in permissions)
                {
                    var permissionItemText = string.Format("{0}=", permission.Key);
                    var list = new List<ChannelPermissions>(permission.Value);
                    foreach (var permissionItemValue in list)
                    {
                        permissionItemText += ((char) permissionItemValue).ToString();
                    }

                    postParameters += string.Format("&{0}", permissionItemText);
                }
            }

            var post = Encoding.UTF8.GetBytes(postParameters);
            var www = new WWW(string.Format("{0}authenticate", connectionUrl), post);
            yield return www;


            if (!string.IsNullOrEmpty(www.error))
            {
                Debug.LogError(www.error);
                callback(
                    new OrtcException(OrtcExceptionReason.Unauthorized,
                        string.Format("Unable to connect to the authentication server {0}.", connectionUrl)),
                    string.Empty);
            }
            else
            {
                callback(null, www.text);
            }
        }
    }
}